#!/bin/bash -e
set -x

# Copyright (C) 2018 Gunter Miegel coinboot.io
#
# This file is part of Coinboot.
#
# Coinboot is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <http://www.gnu.org/licenses/>.

EXCLUDE='^\/(proc|sys|dev|run|tmp|vagrant|var\/log|usr\/share\/dbus-1\/system-services|var\/lib/\dpkg\/[^info]|var\/cache).*'
OUTFILE=/tmp/plugin_file_list
OUTFILE_FINAL=/tmp/plugin_file_list_final
DPKG_STATUS=/var/lib/dpkg/status
INITIAL_DPKG_STATUS=/tmp/initial_status
FINAL_DPKG_STATUS=/tmp/dpkg_status
PID_FILE=/tmp/plugin_create_pid
FLUFFY_LOG_DIR=/opt/fluffy
FLUFFY_LOG=$FLUFFY_LOG_DIR/fluffy.log
FLUFFY_ERROR_LOG=$FLUFFY_LOG_DIR/fluffy_error.log

function start_fluffy {
  # FIXME: fluffy watches at the own outputfiles and ends up in
  # some kind of infinite loop.
  # So we are handling the output to files on our own for now.
  #sudo fluffy \
  #  -O $OUTFILE \
  #  -E /tmp/create_plugin_error.log &

  sudo fluffy \
    -O /tmp/fluffy/fluffy.log \
    -E /tmo/fluffy/fluffy_error.log &

  PID=$!

  echo "PID of the process watching for file changes is: $PID"

  echo $PID > $PID_FILE

  cp -v $DPKG_STATUS $INITIAL_DPKG_STATUS

  sudo rm -rf $FLUFFY_LOG_DIR
  sudo mkdir -pv $FLUFFY_LOG_DIR

  sudo fluffy \
  -O $FLUFFY_LOG_ \
  -E $FLUFFY_ERROR_LOG &

  sudo fluffyctl \
  --create \
  --modify \
  --delete \
  --attrib \
  --moved-from \
  --moved-to \
  --root-delete \
  --root-move \
  --close-write \
  --queue-overflow \
  -w /opt \
  -i $FLUFFY_LOG_DIR \
  -i /tmp \
  -i /proc \
  -i /sys \
  -i /dev \
  -i /run \
  -i /vagrant \
  -i /var/log \
  -i /var/lib/dpkg \
  -w /var/lib/dpkg/info \
  -i /var/cache \
  -w /

  sudo mkdir -p /opt/ready 
    # Inotifywait takes some time to build up the recursive file watching on
    # / - so we have to wait and verify that we only proceed after the prepations
    # are done.
    while ! grep -q '/opt/ready' /opt/fluffy/fluffy.log; do
       echo -ne 'Waiting for file watching to be established...\r'
       sleep 0.2
       sudo mkdir -p /opt/ready 
    done

    sleep 20
    #echo '' > $OUTFILE
    #sudo rm $OUTFILE
    #sudo rm /tmp/create_plugin_error.log
  }

  function start {
    # Inside a Docker container '/proc' is read-only, so we are skipping this step.
    if ! grep -q docker /proc/1/cgroup; then
      echo "200000" | sudo tee /proc/sys/fs/inotify/max_user_watches
    fi

    sudo rm -fv $OUTFILE $OUTFILE_FINAL $INITIAL_DPKG_STATUS $FINAL_DPKG_STATUS $PID_FILE

    # TODO Also track deleted files
    # According to strace is looks like --exclude is not preventing building the
    # "watches" for the excluded directories but filters all file system events on them.
    if [ $(which fswatch) ]; then
      nohup sudo fswatch -x -r \
        --event=Created \
        --event=Updated \
        --event=Removed \
        --event=Renamed \
        --event=OwnerModified \
        --event=AttributeModified \
        --event=MovedFrom \
        --event=MovedTo \
        --extended \
        --exclude $EXCLUDE \
        / > $OUTFILE 2> /tmp/create_plugin.log &
    else
      echo 'fswatch is missing'
      echo 'Please install the package fswatch'
      exit
    fi

    PID=$!

    echo "PID of the process watch for file changes is: $PID"

    echo $PID > $PID_FILE

    # Inotifywait takes some time to build up the recursive file watching on
    # / - so we have to wait and verify that we only proceed after the prepations
    # are done.
   # while ! grep -q 'Watches established.' /tmp/plugin.log; do
   #   echo -ne 'Waiting for file watching to be established...\r'
   #   sleep 0.2
   # done

  }

function finish {
  plugin_name=$1

  sudo kill $(cat /tmp/plugin_create_pid)

  dpkg_status.py --old $INITIAL_DPKG_STATUS --new $DPKG_STATUS --diff > $FINAL_DPKG_STATUS

  # Test all collected files if they really exists and if so write them
  # to a final file list.
  # Finally add the dpkg_status file we create beforehand.
  while read event path; do
    if [ -f "$path" ]; then
      echo $path
      echo $path >> "$OUTFILE_FINAL"
    fi
  done < <(sort -u $OUTFILE)

  echo $FINAL_DPKG_STATUS >> $OUTFILE_FINAL

  tar -czvf $plugin_name.tar.gz -P -T $OUTFILE_FINAL
}

function upload {
  filepath=$1
  url=$2
  filename=$(basename $filepath)
  curl -F "file=@$filepath;filename=$filename" $url
}

case "$1" in
  'start')
  start
  ;;
  'start')
  start_fluffy
  ;;
  'finish')
  finish $2
  ;;
  'upload')
  upload $2 $3
  ;;
esac
